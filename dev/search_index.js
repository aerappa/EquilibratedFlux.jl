var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = EqFlux","category":"page"},{"location":"#EqFlux","page":"Home","title":"EqFlux","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for EqFlux.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [EqFlux]","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"EditURL = \"readme.jl\"","category":"page"},{"location":"examples/readme/readme/#EqFlux.jl","page":"EqFlux.jl","title":"EqFlux.jl","text":"","category":"section"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"(Image: ipynb) (Image: nbviewer)","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"This package is based on the Gridap.jl to provide tools to calculate a posteriori error estimates for numerical solutions of partial differential equations (PDEs). For simplicity, we consider here the Poisson equation","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"beginalign\n- Delta u = f textin Omega\nu = g texton partialOmega\nendalign","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"math","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"We suppose we have already computed a conforming approximation u_h in V_hsubset H^1_0(Omega) to the solution u in Gridap.jl by solving","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"(nabla u_h nabla v_h) = (f v_h)quadforall v_hin V_h","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"for this see for example the first Gridap.jl tutorial. The EqFlux.jl library then provides the tools to compute an estimator eta(u_h) such that the error measured in the H^1_0-seminorm can be bounded as","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"nabla(u - u_h) le eta(u_h)","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"which we refer to as reliability of the estimator. We also can prove the bound","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"eta(u_h) lesssim nabla(u - u_h)","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"which we refer to as efficiency. The main ingredient in computing this estimator is a reconstructed flux obtained by postprocessing that is an approximation to the numerical flux, i.e., sigma_happrox -nabla u_h. This flux has the important property of being \"conservative over faces\" in the sense that","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"sigma_h in mathbfH(mathrmdivOmega)","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"We provide two functions to obtain this object: build_equilibrated_flux and build_average_flux which we denote by sigma_mathrmeqh and sigma_mathrmaveh respectively.","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"In addition, for the equilibrated flux sigma_mathrmeqh satisfies the so-called equilibrium condition, i.e., for piecewise polynomial f, we have","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"nablacdotsigma_mathrmeqh = f","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"In either case,the estimator takes the form","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"eta(u_h) =  sigma_cdoth + nabla u_h","category":"page"},{"location":"examples/readme/readme/#Demonstration","page":"EqFlux.jl","title":"Demonstration","text":"","category":"section"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"We set Omega = (01)^2 to be the unit square in 2D. We use a uniform simplicial mesh mathcalT_h to discretize this domain by the following in Gridap.jl","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"using Gridap\nusing GridapMakie\nusing CairoMakie\n\nn = 10 # Number of elements in x and y for square mesh\ndomain = (0,1,0,1)\npartition = (n, n)\nmodel = CartesianDiscreteModel(domain, partition)\n# Change to triangles\nmodel = simplexify(model)\nùì£‚Çï = Triangulation(model)\nplt = plot(ùì£‚Çï)\nwireframe!(ùì£‚Çï, color=:black)\nplt","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"We manufacture the solution u = sin(2pi x)sin(pi y) by choosing the right hand side:","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"u(x) = sin(2*pi*x[1]) * sin(pi*x[2])\nf(x) = 5 * pi^2 * u(x) # = -Œîu","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"We consider the discrete space","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"V_h = v_hin H_0^1(Omega) v_h_K inmathbbP_k(K)quadforall Kin mathcalT_h","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"This is achieved through the following with Gridap.jl:","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"# Polynomial order\norder = 1\ndegree = 2 * order + 2\ndx = Measure(ùì£‚Çï, degree)\nreffe = ReferenceFE(lagrangian, Float64, order)\nV0 = TestFESpace(model, reffe; conformity = :H1, dirichlet_tags = \"boundary\")\nU = TrialFESpace(V0, u)\na(u, v) = ‚à´(‚àá(v) ‚äô ‚àá(u)) * dx\nb(v) = ‚à´(v * f) * dx\nop = AffineFEOperator(a, b, U, V0)\nuh = solve(op)\nfig_soln, _ , plt = plot(ùì£‚Çï, uh, colormap=:viridis)\nColorbar(fig_soln[1,2], plt)\nfig_soln","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"We can then build the fluxes sigma_mathrmeqh and sigma_mathrmaveh via the following:","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"using EqFlux\nœÉ_eq = build_equilibrated_flux(-‚àá(uh), f, model, order);\nœÉ_ave = build_averaged_flux(-‚àá(uh), model);\nnothing #hide","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"First we calculate the estimators and the error using the fluxes and the approximate solution uh.","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"include(\"helpers.jl\")\n\nH1err¬≤ = L2_norm_squared(‚àá(u - uh), dx)\n@show sqrt(sum(H1err¬≤))\n\nH1err_arr = sqrt.(getindex(H1err¬≤, ùì£‚Çï))\nŒ∑_eq¬≤ = L2_norm_squared(œÉ_eq + ‚àá(uh), dx)\n@show sqrt(sum(Œ∑_eq¬≤))\n\nŒ∑eq_arr = sqrt.(getindex(Œ∑_eq¬≤, ùì£‚Çï))\nŒ∑_ave¬≤ = L2_norm_squared(œÉ_ave + ‚àá(uh), dx)\n@show sqrt(sum(Œ∑_ave¬≤))\n\nŒ∑ave_arr = sqrt.(getindex(Œ∑_ave¬≤, ùì£‚Çï));\nnothing #hide","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"Now we plot the estimators and errors restricted to each element (the full code can be found in helpers.jl)","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"fig = plot_error_and_estimator(ùì£‚Çï, Œ∑ave_arr, Œ∑eq_arr, H1err_arr)","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"We see that both estimators provide a good cellwise approximation of the error, but the one based on the equilibrated flux is closer visually. Next, we consider the divergence error, i.e., how well the reconstructed object satisfies nablacdotsigma = Pi_1 f. In particular, in the following plot we can see that the equilibrated flux estimator satisfies the divergence constraint up to machine precision, but the flux based on averaging does not.","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"f_proj = L¬≤_projection(model, reffe, f, dx)\neq_div  = L2_norm_squared(‚àá ‚ãÖ œÉ_eq - f_proj, dx)\nave_div = L2_norm_squared(‚àá ‚ãÖ œÉ_ave - f_proj, dx)\neq_div_vis = CellField(sqrt.(getindex(eq_div, ùì£‚Çï)), ùì£‚Çï)\nave_div_vis = CellField(sqrt.(getindex(ave_div, ùì£‚Çï)), ùì£‚Çï)\nfig = plot_divergence_misfit(ùì£‚Çï, eq_div_vis, ave_div_vis)","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"","category":"page"},{"location":"examples/readme/readme/","page":"EqFlux.jl","title":"EqFlux.jl","text":"This page was generated using Literate.jl.","category":"page"}]
}
