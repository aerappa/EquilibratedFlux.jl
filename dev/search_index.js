var documenterSearchIndex = {"docs":
[{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"EditURL = \"Lshaped.jl\"","category":"page"},{"location":"examples/Lshaped/Lshaped/#Mesh-refinement","page":"Mesh refinement","title":"Mesh refinement","text":"","category":"section"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"(Image: ipynb) (Image: nbviewer)","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"In this tutorial, we use the estimator obtained by the equilibrated flux to drive an adative mesh refinement (AMR) procedure.  We consider the Laplace problem","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"beginalign\n-Delta u = 0 text in Omega\nu = g text on partialOmega\nendalign","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"on an L-shaped domain Omega = (-11)^2 setminus (01)times(-10).  We load this domain from a json file.","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"using Gridap, GridapMakie, CairoMakie\n\nmodel = DiscreteModelFromFile(\"Lshaped.json\")\nΩ = Triangulation(model)\n\nfig = plot(Ω)\nwireframe!(Ω, color=:black, linewidth=2);\nfig","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"In this case, we know the true solution u is given by the following formula in polar coordinates:","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"\"Have to convert from -[π, π] to [0, 2π]\"\nfunction θ(x)\n  θt = atan(x[2], x[1])\n  (θt >= 0) * θt + (θt < 0) * (θt + 2 * π)\nend\n\nr(x) = sqrt(x[1]^2 + x[2]^2)\n\nα = 2 / 3\n\nu(x) = r(x)^α * sin(θ(x) * α)\nu_fig, _ , plt = plot(Ω, u, colormap=:viridis)\nColorbar(u_fig[1,2], plt)\nu_fig","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"using Gridap.Geometry\nusing Gridap.Adaptivity\nusing EqFlux","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"We define some helper functions for computing the L² norm in Gridap","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"L2_inner_product(f, g, dx) = ∫(f ⋅ g) * dx\n\nL2_norm_squared(f, dx) = L2_inner_product(f, f, dx)\n\nfunction L2_norm_squared(f, model, order)\n  degree = 2 * order + 2\n  Ω = Triangulation(model)\n  dx = Measure(Ω, degree)\n  L2_norm_squared(f, dx)\nend","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"Next, we define the Dörfler marking[1]","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"function dorfler_marking(η_arr)\n  if η_arr isa Gridap.Arrays.LazyArray\n    η_arr = EqFlux.smart_collect(η_arr)\n  end\n  θ = 0.3 # Marking parameter\n  η_tot = sum(η_arr)\n  sorted_inds = sortperm(η_arr, rev = true)\n  sorted = η_arr[sorted_inds]\n  η_partial = 0.0\n  i = 1\n  while η_partial <= θ * η_tot\n    η_partial += sorted[i]\n    i += 1\n  end\n  sorted_inds[1:i]\nend","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"As a small example, we show the result of calling dorfler_marking","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"This step just corresponds almost exact to the contents of the first Gridap.jl tutorial.","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"function solve_laplace(model, order, g)\n  Ω = Triangulation(model)\n  degree = 2 * order + 2\n  dx = Measure(Ω, degree)\n  a(u, v) = ∫(∇(v) ⊙ ∇(u)) * dx\n  b(v) = ∫(v * 0.0) * dx\n  reffe = ReferenceFE(lagrangian, Float64, order)\n  V0 = TestFESpace(model, reffe; conformity = :H1, dirichlet_tags = \"boundary\")\n  U = TrialFESpace(V0, g)\n  op = AffineFEOperator(a, b, U, V0)\n  uh = solve(op)\n  dofs = num_free_dofs(V0)\n  uh, dx, dofs\nend","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"This function uses the EqFlux.jl package to obtain an error estimation on each cell of the mesh.","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"function estimate_laplace(uh, dx, model, order)\n    σ = build_equilibrated_flux(-∇(uh), x -> 0.0, model, order)\n    #σ = build_averaged_flux(∇(uh), model)\n    η² = L2_norm_squared(σ + ∇(uh), dx)\n    Ω = Triangulation(model)\n    getindex(η², Ω)\nend","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"Finally, this function puts the previous functions together into the standard Solve -> Estimate -> Mark -> Refine loop of AFEM. The refinement step using newest vertex bisection can be selected using \"nvb\" with the keyword argument refinement_method. g is the function on the Dirichlet boundary.","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"function solve_estimate_mark_refine_laplace(model, tol, order; g)\n    η = Inf\n    estimators = Float64[]\n    errors = Float64[]\n    num_dofs = Float64[]\n    error_fields = CellField[]\n    while η > tol\n        # We extract the internal model from the refined model\n        if model isa AdaptedDiscreteModel\n            model = model.model\n        end\n        # SOLVE\n        uh, dx, dofs = solve_laplace(model, order, g)\n        push!(num_dofs, dofs)\n        # ESTIMATE\n        η_arr = estimate_laplace(uh, dx, model, order)\n        H1err² = L2_norm_squared(∇(u - uh), dx)\n        Ω = Triangulation(model)\n        error_field = CellField(sqrt.(getindex(H1err², Ω)), Ω)\n        push!(error_fields, error_field)\n        H1err = √sum(H1err²)\n        η = √(sum(η_arr))\n        push!(estimators, η)\n        push!(errors, H1err)\n        # MARK\n        cells_to_refine = dorfler_marking(η_arr)\n        # REFINE\n        model = refine(model, refinement_method = \"nvb\", cells_to_refine = cells_to_refine)\n\n    end\n    return error_fields, num_dofs, estimators, errors\nend","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"We can change the polynomial order here as well as the tolerance for the estimator.","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"order = 2\ntol = 1e-4","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"We pass the true solution as the Dirichlet function g","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"error_fields, num_dofs, estimators, errors = solve_estimate_mark_refine_laplace(model, tol, order, g = u);\nnothing #hide","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"We now show that the AFEM refinement achieves the optimal rate of convergence of mathrmDOFs^-pd = mathrmDOFs^-p2 in 2D.","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"fig = Figure()\naxis = Axis(fig[1,1], xscale = log10, yscale = log10, title = \"Order p=$order\", xlabel = \"DOFs\")\nlines!(axis, num_dofs, errors, label = \"Error\")\nlines!(axis, num_dofs, estimators, label = \"Estimator\")\nlines!(axis, num_dofs, num_dofs.^(-order / 2), label = \"Optimal rate\")\naxislegend()\nfig","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"Finally, the following animation shows the sequence of meshes generated by the adaptive refinement procedure. The refinement is clearly concentrated to the re-entrant corner.","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"let\n    idx = Observable(1)\n    Ωᵢ = lift(idx) do i\n        error_fields[i].trian\n    end\n    nDOFᵢ = lift(idx) do i\n        \"Iteration $i\\n$(Int(num_dofs[i])) DOFs\"\n    end\n\n    fig, ax, plt = plot(Ωᵢ)\n    wireframe!(Ωᵢ, color=:black, linewidth=2)\n    text!(ax, (0.5, -0.5), text=nDOFᵢ, align=(:center, :center), justification=:left)\n\n    record(fig, \"animation.gif\", eachindex(error_fields); framerate=2, compression=0) do i\n       idx[] = i\n    end\nend","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"(Image: )","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"[1] Dörfler, W. A convergent adaptive algorithm for Poisson’s equation. SIAM Journal on Numerical Analysis 33, 3 (1996), 1106–1124","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"","category":"page"},{"location":"examples/Lshaped/Lshaped/","page":"Mesh refinement","title":"Mesh refinement","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = EqFlux","category":"page"},{"location":"#EqFlux","page":"Home","title":"EqFlux","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is based on Gridap.jl to provide post-processing tools to calculate reconstructed fluxes associated to the given approximate solution of a PDE.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For simplicity, we consider here the Poisson equation","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign\n- Delta u = f textin Omega\nu = g texton partialOmega\nendalign","category":"page"},{"location":"","page":"Home","title":"Home","text":"We suppose we have already computed a conforming approximation u_h in V_hsubset H^1_0(Omega) to the solution u in Gridap.jl by solving","category":"page"},{"location":"","page":"Home","title":"Home","text":"(nabla u_h nabla v_h) = (f v_h)quadforall v_hin V_h","category":"page"},{"location":"","page":"Home","title":"Home","text":"The EqFlux.jl library then provides the tools to compute a reconstructed flux associated to u_h. This flux, obtained by postprocessing, is an approximation to the numerical flux, i.e.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sigma_h approx -nabla u_h","category":"page"},{"location":"","page":"Home","title":"Home","text":"This flux has the important property of being \"conservative over faces\" in the sense that","category":"page"},{"location":"","page":"Home","title":"Home","text":"sigma_h in mathbfH(mathrmdivOmega)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We provide two functions to obtain such an object: build_equilibrated_flux and build_averaged_flux both provide reconstructed fluxes, which we denote by sigma_mathrmeqh and sigma_mathrmaveh respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition to the properties listed above, the equilibrated flux sigma_mathrmeqh satisfies the so-called equilibrium condition, i.e., for piecewise polynomial f, we have","category":"page"},{"location":"","page":"Home","title":"Home","text":"nablacdotsigma_mathrmeqh = f","category":"page"},{"location":"","page":"Home","title":"Home","text":"The reconstructed flux is the main ingredient in computing a posteriori error estimators. See the first tutorial for a complete demonstration of how to do this.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [EqFlux]","category":"page"},{"location":"#EqFlux.build_averaged_flux-Tuple{Any, Any}","page":"Home","title":"EqFlux.build_averaged_flux","text":"build_averaged_flux(𝐀ₕ, model)\n\nTODO: relevant docstring\n\n\n\n\n\n","category":"method"},{"location":"#EqFlux.build_equilibrated_flux-NTuple{4, Any}","page":"Home","title":"EqFlux.build_equilibrated_flux","text":"build_equilibrated_flux(𝐀ₕ, f, model, RT_order; measure = nothing, weight= 1.0)\n\nTODO: relevant docstring\n\n\n\n\n\n","category":"method"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"EditURL = \"readme.jl\"","category":"page"},{"location":"examples/readme/readme/#tuto-error-estimation","page":"Error estimation","title":"Error estimation","text":"","category":"section"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"(Image: ipynb) (Image: nbviewer)","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"This package is based on the Gridap.jl to provide tools to calculate a posteriori error estimates for numerical solutions of partial differential equations (PDEs). For simplicity, we consider here the Poisson equation","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"beginalign\n- Delta u = f textin Omega\nu = g texton partialOmega\nendalign","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"We suppose we have already computed a conforming approximation u_h in V_hsubset H^1_0(Omega) to the solution u in Gridap.jl by solving","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"(nabla u_h nabla v_h) = (f v_h)quadforall v_hin V_h","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"for this see for example the first Gridap.jl tutorial. The EqFlux.jl library then provides the tools to compute an estimator eta(u_h) such that the error measured in the H^1_0-seminorm can be bounded as","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"nabla(u - u_h) le eta(u_h)","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"which we refer to as reliability of the estimator. We also can prove the bound","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"eta(u_h) lesssim nabla(u - u_h)","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"which we refer to as efficiency. The main ingredient in computing this estimator is a reconstructed flux obtained by postprocessing that is an approximation to the numerical flux, i.e., sigma_happrox -nabla u_h. This flux has the important property of being \"conservative over faces\" in the sense that","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"sigma_h in mathbfH(mathrmdivOmega)","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"We provide two functions to obtain this object: build_equilibrated_flux and build_average_flux which we denote by sigma_mathrmeqh and sigma_mathrmaveh respectively.","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"In addition, for the equilibrated flux sigma_mathrmeqh satisfies the so-called equilibrium condition, i.e., for piecewise polynomial f, we have","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"nablacdotsigma_mathrmeqh = f","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"In either case,the estimator takes the form","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"eta(u_h) =  sigma_cdoth + nabla u_h","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"We set Omega = (01)^2 to be the unit square in 2D. We use a uniform simplicial mesh mathcalT_h to discretize this domain by the following in Gridap.jl","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"using Gridap\nusing GridapMakie\nusing CairoMakie\n\nn = 10 # Number of elements in x and y for square mesh\ndomain = (0,1,0,1)\npartition = (n, n)\nmodel = CartesianDiscreteModel(domain, partition)\n# Change to triangles\nmodel = simplexify(model)\n𝓣ₕ = Triangulation(model)\nplt = plot(𝓣ₕ)\nwireframe!(𝓣ₕ, color=:black)\nplt","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"We manufacture the solution u = sin(2pi x)sin(pi y) by choosing the right hand side:","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"u(x) = sin(2*pi*x[1]) * sin(pi*x[2])\nf(x) = 5 * pi^2 * u(x) # = -Δu","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"We consider the discrete space","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"V_h = v_hin H_0^1(Omega) v_h_K inmathbbP_k(K)quadforall Kin mathcalT_h","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"This is achieved through the following with Gridap.jl:","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"# Polynomial order\norder = 1\ndegree = 2 * order + 2\ndx = Measure(𝓣ₕ, degree)\nreffe = ReferenceFE(lagrangian, Float64, order)\nV0 = TestFESpace(model, reffe; conformity = :H1, dirichlet_tags = \"boundary\")\nU = TrialFESpace(V0, u)\na(u, v) = ∫(∇(v) ⊙ ∇(u)) * dx\nb(v) = ∫(v * f) * dx\nop = AffineFEOperator(a, b, U, V0)\nuh = solve(op)\nfig_soln, _ , plt = plot(𝓣ₕ, uh, colormap=:viridis)\nColorbar(fig_soln[1,2], plt)\nfig_soln","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"We can then build the fluxes sigma_mathrmeqh and sigma_mathrmaveh via the following:","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"using EqFlux\nσ_eq = build_equilibrated_flux(-∇(uh), f, model, order);\nσ_ave = build_averaged_flux(-∇(uh), model);\nnothing #hide","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"First we calculate the estimators and the error using the fluxes and the approximate solution u_h.","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"include(\"helpers.jl\")\n\nH1err² = L2_norm_squared(∇(u - uh), dx)\n@show sqrt(sum(H1err²))\nH1err_arr = sqrt.(getindex(H1err², 𝓣ₕ));\n\nη_eq² = L2_norm_squared(σ_eq + ∇(uh), dx)\n@show sqrt(sum(η_eq²))\nηeq_arr = sqrt.(getindex(η_eq², 𝓣ₕ));\n\nη_ave² = L2_norm_squared(σ_ave + ∇(uh), dx)\n@show sqrt(sum(η_ave²))\nηave_arr = sqrt.(getindex(η_ave², 𝓣ₕ));\nnothing #hide","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"Now we plot the estimators and errors restricted to each element (the full code can be found in helpers.jl)","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"fig = plot_error_and_estimator(𝓣ₕ, ηave_arr, ηeq_arr, H1err_arr)","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"We see that both estimators provide a good cellwise approximation of the error, but the one based on the equilibrated flux is closer visually. Next, we consider the divergence error, i.e., how well the reconstructed object satisfies nablacdotsigma = Pi_1 f. In particular, in the following plot we can see that the equilibrated flux estimator satisfies the divergence constraint up to machine precision, but the flux based on averaging does not.","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"f_proj = L²_projection(model, reffe, f, dx)\neq_div  = L2_norm_squared(∇ ⋅ σ_eq - f_proj, dx)\nave_div = L2_norm_squared(∇ ⋅ σ_ave - f_proj, dx)\neq_div_vis = CellField(sqrt.(getindex(eq_div, 𝓣ₕ)), 𝓣ₕ)\nave_div_vis = CellField(sqrt.(getindex(ave_div, 𝓣ₕ)), 𝓣ₕ)\nfig = plot_divergence_misfit(𝓣ₕ, eq_div_vis, ave_div_vis)","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"","category":"page"},{"location":"examples/readme/readme/","page":"Error estimation","title":"Error estimation","text":"This page was generated using Literate.jl.","category":"page"}]
}
